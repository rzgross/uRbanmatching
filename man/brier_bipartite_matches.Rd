% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/brier_bipartite_matches.R
\name{brier_bipartite_matches}
\alias{brier_bipartite_matches}
\title{brier_bipartite_matches}
\usage{
brier_bipartite_matches(
  x_mat,
  cov_x,
  weight_list,
  treat_vec,
  match_method = c("with_replacement", "optimal", "greedy"),
  n_sinks = 0L,
  caliper_list = gen_caliper_list(),
  propensity_list = match_propensity_list(NULL),
  sqrt_mahal = TRUE,
  tol_val = NULL,
  design = "cross_all",
  num_folds = 5,
  match_predict_function = match_predict_xgb(),
  silent = !interactive()
)
}
\arguments{
\item{x_mat}{Input/design matrix}

\item{cov_x}{The covariance of \code{x_mat}. Can be rank_adjusted by using \code{covariance_with_ranks}.}

\item{weight_list}{List of weight vectors. See `generate_random_weights` to
automatically generate a reasonable set of vectors.}

\item{treat_vec}{Logical (or 1/0) vector, indicating treatment (or control).}

\item{match_method}{"with_replacement", "optimal", or "greedy"}

\item{n_sinks}{Number of potential matches that don't need to be matched.}

\item{caliper_list}{Forces matches that are close on some metric.}

\item{propensity_list}{Default NULL. List of propensity scores.}

\item{sqrt_mahal}{Whether to use square root of Mahalanobis distances.}

\item{tol_val}{For optimal matches, you can set a tolerance to be within optimality of, which can be zero for perfect optimality.}

\item{design}{see \code{predict_prepare}}

\item{num_folds}{Number of CV folds to use}

\item{match_predict_function}{function to predict treated units}

\item{silent}{Whether to suppress messages as it's running.}
}
\value{
List of matches within sink values,
 and brier scores for each.
}
\description{
Computes all matches, then gets the brier scores for each.
}
