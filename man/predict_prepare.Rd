% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/predict_prepare.R
\name{predict_prepare}
\alias{predict_prepare}
\title{Prepares design matrices and other inputs needed for predictive methods}
\usage{
predict_prepare(
  x_mat,
  index_list,
  design = c("cross_all", "cross_random", "differences_random", "differences_plain")
)
}
\arguments{
\item{x_mat}{original data, i.e. row for each unit}

\item{index_list}{list of indices to use in the matching:
\describe{
  \item{\code{treat_train}}{Index of treated units for the training matrix}
  \item{\code{control_train}}{Index of control units for the training matrix}
  \item{\code{treat_test}}{Index of treated units for the test matrix}
  \item{\code{control_test}}{Index of control units for the test matrix}
}}

\item{design}{The design matrix form do you want to use.
We'll assume that \code{x_mat} is \eqn{n \times k}.
Let \eqn{X_c} be the rows of \code{x_mat} corresponding
to the control units, and \eqn{X_t} the treated units that
pair with \eqn{X_c} (i.e. so the \eqn{i^{\text{th}}} matched
pair will correspond with the \eqn{i^{\text{th}}} row of each),
and thus each matrix will have dimension \eqn{m \times k},
where \eqn{2m \leq n}.
\describe{
  \item{\code{"cross_all"}}{
This will form the \eqn{2m \times 2k} matrix, by having each matched pair
give two rows in the design matrix: each of the two
rows will contain the full treated row of the given pair along with the full
control row, but in one row the pair will be (treated, control), and in the other
(control, treated). For these two rows, the output vector will contain a 1 and a 0
respectively. We construct the following inputs:
\deqn{X =
  \begin{bmatrix}
  X_t& X_c \\
  X_c& X_t \\
  \end{bmatrix}, Y = [1 1 \ldots 1 0 0 \ldots 0]'
}
For the test data, we'll only (WLOG more or less) give the (treat, control)
version, for consistency in evaluation.
}
   \item{\code{"cross_random"}}{
This is similar to the above, except instead of forming all rows in both
ways, we choose (for each pair) between (treated, control) and
(control, treated) randomly. So
\deqn{Y_i =
\begin{cases}
1 & \text{with probability} 0.5 \\
0 & \text{with probability} 0.5
\end{cases}}
And (\eqn{X_i} here meaning the \eqn{i^{\text{th}}} row of the design matrix):
\deqn{X_i =
\begin{cases}
((X_t)_i, (X_c)_i) & Y_i = 1 \\
((X_c)_i, (X_t)_i) & Y_i = 0
\end{cases}}
Giving an \eqn{m \times 2k} design matrix.
}
  \item{\code{"differences_random"}}{For
each pair, our design row will be
the row in \code{x_mat} corresponding to
one unit minus the row corresponding to the
other. Similar to the above, we'll choose
the outcome randomly and decide which unit will
be subtracted from the other based on that, and we'll end up with
an \eqn{m \times k} matrix.
That is:
\deqn{Y_i =
\begin{cases}
1 & \text{with probability} 0.5 \\
0 & \text{with probability} 0.5
\end{cases}}
And:
\deqn{X_i =
\begin{cases}
(X_t)_i - (X_c)_i & Y_i = 1 \\
(X_c)_i - (X_t)_i & Y_i = 0
\end{cases}}
Note that if your \code{x_mat} contains an intercept, it'll
now be a column of zeroes.
}
\item{\code{"differences_plain"}}{
In some cases, you may wish to have the differences and add
customization. So here we essentially do the same as above
but with \eqn{Y_i = 1} for all \eqn{i}, therefore
all differences are returned as \eqn{(X_t)_i - (X_c)_i}
(and will also be \eqn{m \times k}).
}
}}
}
\value{
list:
  \describe{
    \item{\code{x_train}}{Design matrix for training}
    \item{\code{x_test}}{Design matrix for testing}
    \item{\code{y_train}}{Training outcome vector}
    \item{\code{y_test}}{Test outcome vector}
}
}
\description{
It is not immediately clear how to take a match (set of matched pairs)
and "predict" it - essentially you likely want some prediction
function \eqn{f(x, y) -> {0, 1}} (or \eqn{P(1)} etc) where \eqn{x}
and \eqn{y} are rows, one of which is treated and the other control.
This function should also have a property resembling:
\deqn{f(x, y) = 1 - f(y, x)} since there's an inherent symmetry
in the pairs: if you knew which of the two came first, there'd
be nothing to do. In fact, the definition of \eqn{f} would likely be
to predict if (WLOG) \eqn{x} is the treated unit or not.
}
\details{
This function gives various potential design matrix shapes
and corresponding output vectors that all can be used to solve the
above prediction problem. In some scenarios (e.g. if we were content
to use linear models), differences alone might be appropriate. For full
generality, we may wish to use both full vectors.
}
\author{
Colman Humphrey
}
